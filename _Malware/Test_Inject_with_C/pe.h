#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <windows.h>
#include <winnt.h>
#include <limits>

using namespace std;

DWORD RVA2Offset(IMAGE_NT_HEADERS* pe_header, DWORD rva)
{
    for (IMAGE_SECTION_HEADER* section = (IMAGE_SECTION_HEADER*) (&pe_header->OptionalHeader+1); section->Name[0] != NULL; section++)
        if (rva >= section->VirtualAddress && (rva <= section->VirtualAddress + section->SizeOfRawData))
            return section->PointerToRawData + (rva - section->VirtualAddress);
    return 0;
}
DWORD Offset2RVA(IMAGE_NT_HEADERS* pe_header, DWORD offset)
{
    for (IMAGE_SECTION_HEADER* section = (IMAGE_SECTION_HEADER*) (&pe_header->OptionalHeader+1); section->Name[0] != NULL; section++)
        if (offset >= section->PointerToRawData && (offset <= section->PointerToRawData + section->SizeOfRawData))
            return section->VirtualAddress + (offset - section->PointerToRawData);
    return 0;
}
class PE_FILE
{
private:
    string name;
    map<string, vector<string>> import;
    vector<char> data;
    IMAGE_DOS_HEADER* dos_header;
    IMAGE_NT_HEADERS32* pe_header;
public:
    DWORD RVA2DataPos(DWORD rva)
    {
        return RVA2Offset(pe_header,rva);
    }
    DWORD DataPos2RVA(DWORD offset)
    {
        return Offset2RVA(pe_header,offset);
    }
    char* DataPos2DataPointer(DWORD pos)
    {
        return &data[0]+pos;
    }
    DWORD DataPointer2DataPos(char* pos)
    {
        return (DWORD) (pos-&data[0]);
    }
    char* RVA2DataPointer(DWORD rva)
    {
        return DataPos2DataPointer(RVA2DataPos(rva));
    }
    DWORD DataPointer2RVA(char* pos)
    {
        return DataPos2RVA(DataPointer2DataPos(pos));
    }

    DWORD align(DWORD address)
    {
        return (((address + pe_header->OptionalHeader.SectionAlignment - 1) / pe_header->OptionalHeader.SectionAlignment) * pe_header->OptionalHeader.SectionAlignment);
    }
    IMAGE_SECTION_HEADER* getLastSection()
    {
        IMAGE_SECTION_HEADER* pSection = (IMAGE_SECTION_HEADER*) (&pe_header->OptionalHeader+1);
        IMAGE_SECTION_HEADER* pLastSection = pSection;
        for (int i=0; i<pe_header->FileHeader.NumberOfSections; i++, pSection++)
            if (pLastSection->PointerToRawData < pSection->PointerToRawData)
                pLastSection = pSection;
        return pLastSection;
    }
    DWORD get_func_va(string funcName)
    {
        DWORD dir_offset = RVA2DataPos(pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
        if (dir_offset!=0)
        {
            for (IMAGE_IMPORT_DESCRIPTOR* p = (IMAGE_IMPORT_DESCRIPTOR*) DataPos2DataPointer(dir_offset); p->Name!=0; p++)
                if (p->FirstThunk!=0)
                {
                    int i=0;
                    for (IMAGE_THUNK_DATA32* pThunk = (IMAGE_THUNK_DATA32*) RVA2DataPointer(p->FirstThunk); pThunk->u1.AddressOfData!=0; i++, pThunk++)
                        if (pThunk->u1.Ordinal<IMAGE_ORDINAL_FLAG32)
                        {
                            string func_name="";
                            for (DWORD i=RVA2DataPos(pThunk->u1.AddressOfData)+2; data[i]!=0; i++)
                                func_name+= data[i];
                            if (func_name==funcName)
                                return pe_header->OptionalHeader.ImageBase + DataPointer2RVA((char*)pThunk);
                        }
                }
        }
        return 0;
    }
    void assign_pointer()
    {
        dos_header = (IMAGE_DOS_HEADER*) &data[0];
        pe_header = (IMAGE_NT_HEADERS*) (&data[0] + dos_header->e_lfanew);
    }
    void read_data(string fileName)
    {
        ifstream file(fileName,std::ios::in|std::ios::binary);
        file.ignore( numeric_limits<std::streamsize>::max() );
        int length = file.gcount();
        file.clear();
        file.seekg( 0, std::ios_base::beg );
        if (!length)
        {
            cout << "File does not exists or can't be read.\n";
            return;
        }
        data.resize(length);
        file.read(&data[0],length);
        file.close();

        name = fileName;
        assign_pointer();
        import.clear();
    }

    char* insert_bytes(DWORD offset, int nCount)
    {
        data.insert(data.begin()+offset,nCount,0);
        assign_pointer();
        return DataPos2DataPointer(offset);
    }
    void insert_text_box(string text)
    {
        text+='\0';
        add_func("MessageBoxA","user32.dll");
        apply_imports();
        BYTE byte_code[] = { 0x6A, 0x00, 0x6A, 0x00, 0x68, 0x6A, 0x00, 0xFF, 0x15, 0xB8, 0xFF, 0xE0 };

        //Enlarge last section and add text
        char* pText = append_last_section(100);
        IMAGE_SECTION_HEADER* pLastSection = getLastSection();
        pLastSection->Characteristics |= 0x80000000 | 0x40000000 | 0x20000000;
        DWORD textVA = DataPointer2RVA(pText) + pe_header->OptionalHeader.ImageBase;
        memcpy(pText,&text[0],text.size());

        //Change OEP
        DWORD oldEP = pe_header->OptionalHeader.AddressOfEntryPoint;
        char* pNewEP = pText + text.size();
        pe_header->OptionalHeader.AddressOfEntryPoint = DataPointer2RVA(pNewEP);

        //push 0
        //push 0
        memcpy(pNewEP, byte_code,4);
        pNewEP+=4;
        //push textVA
        memcpy(pNewEP,byte_code+4,1);
        pNewEP++;
        memcpy(pNewEP,&textVA,sizeof(DWORD));
        pNewEP+=sizeof(DWORD);
        //call MessageBoxA
        memcpy(pNewEP,byte_code+5,4);
        pNewEP+=4;
        DWORD funcVA = get_func_va("MessageBoxA");
        memcpy(pNewEP,&funcVA,sizeof(DWORD));
        pNewEP+=sizeof(DWORD);
        //move eax, oldEPVA
        memcpy(pNewEP,byte_code+9,1);
        pNewEP++;
        oldEP+=pe_header->OptionalHeader.ImageBase;
        memcpy(pNewEP,&oldEP,sizeof(DWORD));
        pNewEP+=sizeof(DWORD);
        //jmp eax
        memcpy(pNewEP,byte_code+10,2);
    }
    char* append_last_section(int nCount)
    {
        //Insert Section Header Data
        IMAGE_SECTION_HEADER* pLastSection = getLastSection();

        pLastSection->Characteristics |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE;
        int size_append = align(nCount);
        pLastSection->Misc.VirtualSize += align(nCount);
        pLastSection->SizeOfRawData += align(nCount);
        pe_header->OptionalHeader.SizeOfImage += align(nCount);

        pe_header->OptionalHeader.SizeOfCode += align(nCount);
        pe_header->OptionalHeader.SizeOfInitializedData += align(nCount);

        //Append Section Space
        return insert_bytes(pLastSection->PointerToRawData+pLastSection->SizeOfRawData - align(nCount),align(nCount));
    }
    void add_import(string importName)
    {
        if (import.find(importName)==import.end())
            import[importName] = vector<string>();
    }
    void add_func(string funcName, string importName)
    {
        add_import(importName+'\0');
        import[importName+'\0'].push_back(funcName+'\0');
    }
    void apply_imports()
    {
        //Count New Import Table Size
        int nImport = import.size();
        int nFunc = 0;
        int space_for_import_names = 0;
        int space_for_func_names = 0;
        for (map<string, vector<string>>::iterator i=import.begin(); i!=import.end(); i++)
        {
            for (int j=0; j<i->second.size(); j++)
                space_for_func_names+= i->second[j].length();
            space_for_func_names+=2;
            space_for_import_names+= i->first.length();
            nFunc+=i->second.size();
        }
        DWORD import_dir_offset = RVA2DataPos(pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
        if (import_dir_offset!=0)
            for (IMAGE_IMPORT_DESCRIPTOR* p = (IMAGE_IMPORT_DESCRIPTOR*) DataPos2DataPointer(import_dir_offset); p->Name!=0; p++)
                nImport++;

        //Append To Last Section
        DWORD append_size = (nImport+1)*sizeof(IMAGE_IMPORT_DESCRIPTOR) + (nFunc+import.size())*sizeof(IMAGE_THUNK_DATA32) + space_for_func_names + space_for_import_names;

        IMAGE_IMPORT_DESCRIPTOR* pIIDs = (IMAGE_IMPORT_DESCRIPTOR*) append_last_section(append_size);
        IMAGE_THUNK_DATA32* pThunks = (IMAGE_THUNK_DATA32*) (pIIDs + nImport+1);
        char* pImportNames = (char*) (pThunks + nFunc+import.size()+1);
        char* pFuncNames = pImportNames + space_for_import_names;

        //Set Data
        pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size+=import.size();
        pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = DataPointer2RVA((char*)pIIDs);

        if (import_dir_offset)
            memcpy(pIIDs, DataPos2DataPointer(import_dir_offset), (nImport-import.size())*sizeof(IMAGE_IMPORT_DESCRIPTOR));
        pIIDs += nImport-import.size();
        for (map<string, vector<string>>::iterator i=import.begin(); i!=import.end(); i++, pIIDs++)
        {
            pIIDs->Name = DataPointer2RVA(pImportNames);
            memcpy(pImportNames, &(i->first[0]), i->first.length());
            pImportNames+=i->first.length();
            pIIDs->OriginalFirstThunk = pIIDs->FirstThunk = DataPointer2RVA((char*)pThunks);
            for (int j=0; j<i->second.size(); j++, pThunks++)
            {
                pThunks->u1.Ordinal = DataPointer2RVA(pFuncNames);
                memcpy(pFuncNames+2,&(i->second[j][0]),i->second[j].size());
                pFuncNames+= 2 + i->second[j].size();
            }
        }

    }

    void print_info()
    {
        cout << std::hex << "--------------------------------------------------------------------------------------\n";
        cout << "AddressOfEntryPoint: " << pe_header->OptionalHeader.AddressOfEntryPoint << "h\n";
        cout << "CheckSum: " << pe_header->OptionalHeader.CheckSum << "h\n";
        cout << "ImageBase: " << pe_header->OptionalHeader.ImageBase << "h\n";
        cout << "FileAlignment: " << pe_header->OptionalHeader.FileAlignment << "h\n";
        cout << "SizeOfImage: " << pe_header->OptionalHeader.SizeOfImage << "h\n";
        cout << "Secion Alignment" << pe_header->OptionalHeader.SectionAlignment << "h\n";
        cout << std::dec << "--------------------------------------------------------------------------------------\n";
    }

    void print_header_info()
    {
        cout <<"--------------------------------------------------------------------------------------\n";
        IMAGE_SECTION_HEADER* pHeader = (IMAGE_SECTION_HEADER*) (&pe_header->OptionalHeader+1);
        for (int i=0; i<pe_header->FileHeader.NumberOfSections; i++)
        {
            cout << "Section " << i << '\n';
            cout << "\tName: " << (pHeader+i)->Name << '\n';
            cout << std::hex;
            cout << "\t Characteristics: " << (pHeader+i)->Characteristics << '\n';
            cout << "\t Raw Address: " << (pHeader+i)->PointerToRawData << '\n';
            cout << "\t Raw Size: " << (pHeader+i)->SizeOfRawData << '\n';
            cout << "\t Virtual Address: " << (pHeader+i)->VirtualAddress << '\n';
            cout << "\t Virtual Size: " << (pHeader+i)->Misc.VirtualSize << '\n';
            cout << std::dec;
        }
        cout << "Number of Sections: " << pe_header->FileHeader.NumberOfSections << '\n';
        cout <<"--------------------------------------------------------------------------------------\n";
    }
    void print_import_info()
    {
        DWORD import_dir_rva = pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
        DWORD dir_offset = RVA2DataPos(import_dir_rva);
        if (dir_offset==0)
        {
            cout << "--------------------------------------------------------------------------------------\n";
            cout << "No Import Function\n";
            cout << "--------------------------------------------------------------------------------------\n";
            return;
        }
        cout << "--------------------------------------------------------------------------------------\n";
        cout << "--------Imports-------\n";
        int nImport = 0;
        int nFunc = 0;
        string importName;
        string funcName;
        HMODULE hMod;
        void* pFunc;
        for (IMAGE_IMPORT_DESCRIPTOR* p = (IMAGE_IMPORT_DESCRIPTOR*) DataPos2DataPointer(dir_offset); p->Name!=0; p++,nImport++)
        {
            importName = "";
            for (DWORD i=RVA2DataPos(p->Name); data[i]!=0; i++)
                importName+=data[i];
            cout << importName << " ----- " << std::hex << DataPointer2RVA((char*) p) << std::dec << '\n';
            hMod = GetModuleHandle(importName.c_str());
            if (p->FirstThunk!=0)
                for (IMAGE_THUNK_DATA32* pThunk = (IMAGE_THUNK_DATA32*) RVA2DataPointer(p->OriginalFirstThunk); pThunk->u1.AddressOfData!=0; pThunk++,nFunc++)
                    //By Ordinal
                    if (pThunk->u1.Ordinal>=IMAGE_ORDINAL_FLAG32)
                        cout << std::hex << '\t' << (pThunk->u1.Ordinal^IMAGE_ORDINAL_FLAG32) << '\n';
                    //By Name
                    else
                    {
                        funcName = "";
                        for (DWORD i=RVA2DataPos(pThunk->u1.AddressOfData)+2; data[i]!=0; i++)
                            funcName+=data[i];
                        cout << "RVA: " << std::hex << (DWORD) DataPointer2RVA((char*)pThunk) << std::dec << '\t' << funcName;
                        cout << '\n';
                    }
        }
        cout << "Number of Imports: " << nImport << '\n';
        cout << "Number of Import Functions: " << nFunc << '\n';

        cout << "--------------------------------------------------------------------------------------\n";
    }
    void print_export_info()
    {
        DWORD export_dir_rva = pe_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        DWORD dir_offset = RVA2DataPos(export_dir_rva);
        if (dir_offset==0)
        {
            cout << "--------------------------------------------------------------------------------------\n";
            cout << "No Export Function\n";
            cout << "--------------------------------------------------------------------------------------\n";
            return;
        }
        cout << "--------------------------------------------------------------------------------------\n";
        cout << "--------Exports-------\n";

        IMAGE_EXPORT_DIRECTORY* export_dir = (IMAGE_EXPORT_DIRECTORY*) DataPos2DataPointer(dir_offset);
        for (DWORD* pName=(DWORD*) RVA2DataPointer(export_dir->AddressOfNames), i=0; i<export_dir->NumberOfNames; pName++, i++)
        {
            cout << '\t';
            for (DWORD i=RVA2DataPos(*pName); data[i]!=0; i++)
                cout << data[i];
            cout << '\n';
        }
        cout << "Export Dir Offset: " << std::hex << dir_offset << std::dec << "h\n";
        cout << "Export Number of Functions: " << export_dir->NumberOfFunctions << '\n';
        cout << "Export Number of Names: " << export_dir->NumberOfNames << '\n';
        cout << "--------------------------------------------------------------------------------------\n";
    }
    void save_as(string fileName)
    {
        ofstream file(fileName,std::ios::out|std::ios::binary);
        file.write(&data[0],data.size());
        file.close();
    }
};

bool isx32(FILE* targetFile)
{
    fseek(targetFile,((IMAGE_DOS_HEADER*)0)->e_lfanew + 4,SEEK_SET);
    if (fgetc(targetFile)=='L')
        return true;
    return false;
}

